{"remainingRequest":"D:\\2021graduate\\graduation\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\2021graduate\\graduation\\node_modules\\mint-ui\\packages\\swipe\\src\\swipe.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\2021graduate\\graduation\\node_modules\\mint-ui\\packages\\swipe\\src\\swipe.vue","mtime":1611497133402},{"path":"D:\\2021graduate\\graduation\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1594033213228},{"path":"D:\\2021graduate\\graduation\\node_modules\\babel-loader\\lib\\index.js","mtime":1594033213222},{"path":"D:\\2021graduate\\graduation\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1594033213228},{"path":"D:\\2021graduate\\graduation\\node_modules\\vue-loader\\lib\\index.js","mtime":1594033220124}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7IG9uY2UgfSBmcm9tICdtaW50LXVpL3NyYy91dGlscy9kb20nOwppbXBvcnQgeyBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MgfSBmcm9tICdtaW50LXVpL3NyYy91dGlscy9kb20nOwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdtdC1zd2lwZScsCgogIGNyZWF0ZWQoKSB7CiAgICB0aGlzLmRyYWdTdGF0ZSA9IHt9OwogIH0sCgogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICByZWFkeTogZmFsc2UsCiAgICAgIGRyYWdnaW5nOiBmYWxzZSwKICAgICAgdXNlclNjcm9sbGluZzogZmFsc2UsCiAgICAgIGFuaW1hdGluZzogZmFsc2UsCiAgICAgIGluZGV4OiAwLAogICAgICBwYWdlczogW10sCiAgICAgIHRpbWVyOiBudWxsLAogICAgICByZUluaXRUaW1lcjogbnVsbCwKICAgICAgbm9EcmFnOiBmYWxzZSwKICAgICAgaXNEb25lOiBmYWxzZQogICAgfTsKICB9LAoKICBwcm9wczogewogICAgc3BlZWQ6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAzMDAKICAgIH0sCgogICAgZGVmYXVsdEluZGV4OiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMAogICAgfSwKCiAgICBhdXRvOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMzAwMAogICAgfSwKCiAgICBjb250aW51b3VzOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IHRydWUKICAgIH0sCgogICAgc2hvd0luZGljYXRvcnM6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogdHJ1ZQogICAgfSwKCiAgICBub0RyYWdXaGVuU2luZ2xlOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IHRydWUKICAgIH0sCgogICAgcHJldmVudDogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKCiAgICBzdG9wUHJvcGFnYXRpb246IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0KICB9LAoKICB3YXRjaDogewogICAgaW5kZXgobmV3SW5kZXgpIHsKICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgbmV3SW5kZXgpOwogICAgfQogIH0sCgogIG1ldGhvZHM6IHsKICAgIHN3aXBlSXRlbUNyZWF0ZWQoKSB7CiAgICAgIGlmICghdGhpcy5yZWFkeSkgcmV0dXJuOwoKICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVJbml0VGltZXIpOwogICAgICB0aGlzLnJlSW5pdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgdGhpcy5yZUluaXRQYWdlcygpOwogICAgICB9LCAxMDApOwogICAgfSwKCiAgICBzd2lwZUl0ZW1EZXN0cm95ZWQoKSB7CiAgICAgIGlmICghdGhpcy5yZWFkeSkgcmV0dXJuOwoKICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVJbml0VGltZXIpOwogICAgICB0aGlzLnJlSW5pdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgdGhpcy5yZUluaXRQYWdlcygpOwogICAgICB9LCAxMDApOwogICAgfSwKCiAgICByYWZUcmFuc2xhdGUoZWxlbWVudCwgaW5pdE9mZnNldCwgb2Zmc2V0LCBjYWxsYmFjaywgbmV4dEVsZW1lbnQpIHsKICAgICAgbGV0IEFMUEhBID0gMC44ODsKICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlOwogICAgICB2YXIgX29mZnNldCA9IGluaXRPZmZzZXQ7CiAgICAgIHZhciByYWYgPSAwOwoKICAgICAgZnVuY3Rpb24gYW5pbWF0aW9uTG9vcCgpIHsKICAgICAgICBpZiAoTWF0aC5hYnMoX29mZnNldCAtIG9mZnNldCkgPCAwLjUpIHsKICAgICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7CiAgICAgICAgICBfb2Zmc2V0ID0gb2Zmc2V0OwogICAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnJzsKICAgICAgICAgIGlmIChuZXh0RWxlbWVudCkgewogICAgICAgICAgICBuZXh0RWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnJzsKICAgICAgICAgIH0KICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7CgogICAgICAgICAgaWYgKGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKCk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgX29mZnNldCA9IEFMUEhBICogX29mZnNldCArICgxLjAgLSBBTFBIQSkgKiBvZmZzZXQ7CiAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtfb2Zmc2V0fXB4LCAwLCAwKWA7CgogICAgICAgIGlmIChuZXh0RWxlbWVudCkgewogICAgICAgICAgbmV4dEVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7X29mZnNldCAtIG9mZnNldH1weCwgMCwgMClgOwogICAgICAgIH0KCiAgICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkxvb3AuYmluZCh0aGlzKSk7CiAgICAgIH0KCiAgICAgIGFuaW1hdGlvbkxvb3AuY2FsbCh0aGlzKTsKICAgIH0sCgogICAgdHJhbnNsYXRlKGVsZW1lbnQsIG9mZnNldCwgc3BlZWQsIGNhbGxiYWNrKSB7CiAgICAgIGlmIChzcGVlZCkgewogICAgICAgIHRoaXMuYW5pbWF0aW5nID0gdHJ1ZTsKICAgICAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnLXdlYmtpdC10cmFuc2Zvcm0gJyArIHNwZWVkICsgJ21zIGVhc2UtaW4tb3V0JzsKICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7b2Zmc2V0fXB4LCAwLCAwKWA7CiAgICAgICAgfSwgNTApOwoKICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7CgogICAgICAgIHZhciB0cmFuc2l0aW9uRW5kQ2FsbGJhY2sgPSAoKSA9PiB7CiAgICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47CiAgICAgICAgICBjYWxsZWQgPSB0cnVlOwogICAgICAgICAgdGhpcy5hbmltYXRpbmcgPSBmYWxzZTsKICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnOwogICAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnJzsKICAgICAgICAgIGlmIChjYWxsYmFjaykgewogICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgIH07CgogICAgICAgIG9uY2UoZWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0cmFuc2l0aW9uRW5kQ2FsbGJhY2spOwogICAgICAgIHNldFRpbWVvdXQodHJhbnNpdGlvbkVuZENhbGxiYWNrLCBzcGVlZCArIDEwMCk7IC8vIHdlYmtpdFRyYW5zaXRpb25FbmQgbWF5YmUgbm90IGZpcmUgb24gbG93ZXIgdmVyc2lvbiBhbmRyb2lkLgogICAgICB9IGVsc2UgewogICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnOwogICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7b2Zmc2V0fXB4LCAwLCAwKWA7CiAgICAgIH0KICAgIH0sCgogICAgcmVJbml0UGFnZXMoKSB7CiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJGNoaWxkcmVuOwogICAgICB0aGlzLm5vRHJhZyA9IGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm5vRHJhZ1doZW5TaW5nbGU7CgogICAgICB2YXIgcGFnZXMgPSBbXTsKICAgICAgdmFyIGludERlZmF1bHRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kZWZhdWx0SW5kZXgpOwogICAgICB2YXIgZGVmYXVsdEluZGV4ID0gKGludERlZmF1bHRJbmRleCA+PSAwICYmIGludERlZmF1bHRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkgPyBpbnREZWZhdWx0SW5kZXggOiAwOwogICAgICB0aGlzLmluZGV4ID0gZGVmYXVsdEluZGV4OwoKICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHsKICAgICAgICBwYWdlcy5wdXNoKGNoaWxkLiRlbCk7CgogICAgICAgIHJlbW92ZUNsYXNzKGNoaWxkLiRlbCwgJ2lzLWFjdGl2ZScpOwoKICAgICAgICBpZiAoaW5kZXggPT09IGRlZmF1bHRJbmRleCkgewogICAgICAgICAgYWRkQ2xhc3MoY2hpbGQuJGVsLCAnaXMtYWN0aXZlJyk7CiAgICAgICAgfQogICAgICB9KTsKCiAgICAgIHRoaXMucGFnZXMgPSBwYWdlczsKICAgIH0sCgogICAgZG9BbmltYXRlKHRvd2FyZHMsIG9wdGlvbnMpIHsKICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwogICAgICBpZiAoIW9wdGlvbnMgJiYgdGhpcy4kY2hpbGRyZW4ubGVuZ3RoIDwgMikgcmV0dXJuOwoKICAgICAgdmFyIHByZXZQYWdlLCBuZXh0UGFnZSwgY3VycmVudFBhZ2UsIHBhZ2VXaWR0aCwgb2Zmc2V0TGVmdCwgc3BlZWRYOwogICAgICB2YXIgc3BlZWQgPSB0aGlzLnNwZWVkIHx8IDMwMDsKICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDsKICAgICAgdmFyIHBhZ2VzID0gdGhpcy5wYWdlczsKICAgICAgdmFyIHBhZ2VDb3VudCA9IHBhZ2VzLmxlbmd0aDsKCiAgICAgIGlmICghb3B0aW9ucykgewogICAgICAgIHBhZ2VXaWR0aCA9IHRoaXMuJGVsLmNsaWVudFdpZHRoOwogICAgICAgIGN1cnJlbnRQYWdlID0gcGFnZXNbaW5kZXhdOwogICAgICAgIHByZXZQYWdlID0gcGFnZXNbaW5kZXggLSAxXTsKICAgICAgICBuZXh0UGFnZSA9IHBhZ2VzW2luZGV4ICsgMV07CiAgICAgICAgaWYgKHRoaXMuY29udGludW91cyAmJiBwYWdlcy5sZW5ndGggPiAxKSB7CiAgICAgICAgICBpZiAoIXByZXZQYWdlKSB7CiAgICAgICAgICAgIHByZXZQYWdlID0gcGFnZXNbcGFnZXMubGVuZ3RoIC0gMV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIW5leHRQYWdlKSB7CiAgICAgICAgICAgIG5leHRQYWdlID0gcGFnZXNbMF07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChwcmV2UGFnZSkgewogICAgICAgICAgcHJldlBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7CiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShwcmV2UGFnZSwgLXBhZ2VXaWR0aCk7CiAgICAgICAgfQogICAgICAgIGlmIChuZXh0UGFnZSkgewogICAgICAgICAgbmV4dFBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7CiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShuZXh0UGFnZSwgcGFnZVdpZHRoKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcHJldlBhZ2UgPSBvcHRpb25zLnByZXZQYWdlOwogICAgICAgIGN1cnJlbnRQYWdlID0gb3B0aW9ucy5jdXJyZW50UGFnZTsKICAgICAgICBuZXh0UGFnZSA9IG9wdGlvbnMubmV4dFBhZ2U7CiAgICAgICAgcGFnZVdpZHRoID0gb3B0aW9ucy5wYWdlV2lkdGg7CiAgICAgICAgb2Zmc2V0TGVmdCA9IG9wdGlvbnMub2Zmc2V0TGVmdDsKICAgICAgICBzcGVlZFggPSBvcHRpb25zLnNwZWVkWDsKICAgICAgfQoKICAgICAgdmFyIG5ld0luZGV4OwoKICAgICAgdmFyIG9sZFBhZ2UgPSB0aGlzLiRjaGlsZHJlbltpbmRleF0uJGVsOwoKICAgICAgaWYgKHRvd2FyZHMgPT09ICdwcmV2JykgewogICAgICAgIGlmIChpbmRleCA+IDApIHsKICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXggLSAxOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5jb250aW51b3VzICYmIGluZGV4ID09PSAwKSB7CiAgICAgICAgICBuZXdJbmRleCA9IHBhZ2VDb3VudCAtIDE7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKHRvd2FyZHMgPT09ICduZXh0JykgewogICAgICAgIGlmIChpbmRleCA8IHBhZ2VDb3VudCAtIDEpIHsKICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXggKyAxOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5jb250aW51b3VzICYmIGluZGV4ID09PSBwYWdlQ291bnQgLSAxKSB7CiAgICAgICAgICBuZXdJbmRleCA9IDA7CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgY2FsbGJhY2sgPSAoKSA9PiB7CiAgICAgICAgaWYgKG5ld0luZGV4ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIHZhciBuZXdQYWdlID0gdGhpcy4kY2hpbGRyZW5bbmV3SW5kZXhdLiRlbDsKICAgICAgICAgIHJlbW92ZUNsYXNzKG9sZFBhZ2UsICdpcy1hY3RpdmUnKTsKICAgICAgICAgIGFkZENsYXNzKG5ld1BhZ2UsICdpcy1hY3RpdmUnKTsKCiAgICAgICAgICB0aGlzLmluZGV4ID0gbmV3SW5kZXg7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLmlzRG9uZSkgewogICAgICAgICAgdGhpcy5lbmQoKTsKICAgICAgICB9CgogICAgICAgIGlmIChwcmV2UGFnZSkgewogICAgICAgICAgcHJldlBhZ2Uuc3R5bGUuZGlzcGxheSA9ICcnOwogICAgICAgIH0KCiAgICAgICAgaWYgKG5leHRQYWdlKSB7CiAgICAgICAgICBuZXh0UGFnZS5zdHlsZS5kaXNwbGF5ID0gJyc7CiAgICAgICAgfQogICAgICB9OwoKICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgaWYgKHRvd2FyZHMgPT09ICduZXh0JykgewogICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlOwogICAgICAgICAgdGhpcy5iZWZvcmUoY3VycmVudFBhZ2UpOwogICAgICAgICAgaWYgKHNwZWVkWCkgewogICAgICAgICAgICB0aGlzLnJhZlRyYW5zbGF0ZShjdXJyZW50UGFnZSwgb2Zmc2V0TGVmdCwgLXBhZ2VXaWR0aCwgY2FsbGJhY2ssIG5leHRQYWdlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGN1cnJlbnRQYWdlLCAtcGFnZVdpZHRoLCBzcGVlZCwgY2FsbGJhY2spOwogICAgICAgICAgICBpZiAobmV4dFBhZ2UpIHsKICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShuZXh0UGFnZSwgMCwgc3BlZWQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0b3dhcmRzID09PSAncHJldicpIHsKICAgICAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTsKICAgICAgICAgIHRoaXMuYmVmb3JlKGN1cnJlbnRQYWdlKTsKICAgICAgICAgIGlmIChzcGVlZFgpIHsKICAgICAgICAgICAgdGhpcy5yYWZUcmFuc2xhdGUoY3VycmVudFBhZ2UsIG9mZnNldExlZnQsIHBhZ2VXaWR0aCwgY2FsbGJhY2ssIHByZXZQYWdlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGN1cnJlbnRQYWdlLCBwYWdlV2lkdGgsIHNwZWVkLCBjYWxsYmFjayk7CiAgICAgICAgICAgIGlmIChwcmV2UGFnZSkgewogICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHByZXZQYWdlLCAwLCBzcGVlZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5pc0RvbmUgPSBmYWxzZTsKICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGN1cnJlbnRQYWdlLCAwLCBzcGVlZCwgY2FsbGJhY2spOwogICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXRMZWZ0ICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICBpZiAocHJldlBhZ2UgJiYgb2Zmc2V0TGVmdCA+IDApIHsKICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShwcmV2UGFnZSwgcGFnZVdpZHRoICogLTEsIHNwZWVkKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAobmV4dFBhZ2UgJiYgb2Zmc2V0TGVmdCA8IDApIHsKICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShuZXh0UGFnZSwgcGFnZVdpZHRoLCBzcGVlZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmIChwcmV2UGFnZSkgewogICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHByZXZQYWdlLCBwYWdlV2lkdGggKiAtMSwgc3BlZWQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChuZXh0UGFnZSkgewogICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKG5leHRQYWdlLCBwYWdlV2lkdGgsIHNwZWVkKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgMTApOwogICAgfSwKCiAgICBuZXh0KCkgewogICAgICB0aGlzLmRvQW5pbWF0ZSgnbmV4dCcpOwogICAgfSwKCiAgICBwcmV2KCkgewogICAgICB0aGlzLmRvQW5pbWF0ZSgncHJldicpOwogICAgfSwKCiAgICBiZWZvcmUoKSB7CiAgICAgIHRoaXMuJGVtaXQoJ2JlZm9yZScsIHRoaXMuaW5kZXgpOwogICAgfSwKCiAgICBlbmQoKSB7CiAgICAgIHRoaXMuJGVtaXQoJ2VuZCcsIHRoaXMuaW5kZXgpOwogICAgfSwKCiAgICBkb09uVG91Y2hTdGFydChldmVudCkgewogICAgICBpZiAodGhpcy5ub0RyYWcpIHJldHVybjsKCiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWw7CiAgICAgIHZhciBkcmFnU3RhdGUgPSB0aGlzLmRyYWdTdGF0ZTsKICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTsKCiAgICAgIGRyYWdTdGF0ZS5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgICBkcmFnU3RhdGUuc3RhcnRMZWZ0ID0gdG91Y2gucGFnZVg7CiAgICAgIGRyYWdTdGF0ZS5zdGFydFRvcCA9IHRvdWNoLnBhZ2VZOwogICAgICBkcmFnU3RhdGUuc3RhcnRUb3BBYnNvbHV0ZSA9IHRvdWNoLmNsaWVudFk7CgogICAgICBkcmFnU3RhdGUucGFnZVdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDsKICAgICAgZHJhZ1N0YXRlLnBhZ2VIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDsKCiAgICAgIHZhciBwcmV2UGFnZSA9IHRoaXMuJGNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXTsKICAgICAgdmFyIGRyYWdQYWdlID0gdGhpcy4kY2hpbGRyZW5bdGhpcy5pbmRleF07CiAgICAgIHZhciBuZXh0UGFnZSA9IHRoaXMuJGNoaWxkcmVuW3RoaXMuaW5kZXggKyAxXTsKCiAgICAgIGlmICh0aGlzLmNvbnRpbnVvdXMgJiYgdGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7CiAgICAgICAgaWYgKCFwcmV2UGFnZSkgewogICAgICAgICAgcHJldlBhZ2UgPSB0aGlzLiRjaGlsZHJlblt0aGlzLiRjaGlsZHJlbi5sZW5ndGggLSAxXTsKICAgICAgICB9CiAgICAgICAgaWYgKCFuZXh0UGFnZSkgewogICAgICAgICAgbmV4dFBhZ2UgPSB0aGlzLiRjaGlsZHJlblswXTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGRyYWdTdGF0ZS5wcmV2UGFnZSA9IHByZXZQYWdlID8gcHJldlBhZ2UuJGVsIDogbnVsbDsKICAgICAgZHJhZ1N0YXRlLmRyYWdQYWdlID0gZHJhZ1BhZ2UgPyBkcmFnUGFnZS4kZWwgOiBudWxsOwogICAgICBkcmFnU3RhdGUubmV4dFBhZ2UgPSBuZXh0UGFnZSA/IG5leHRQYWdlLiRlbCA6IG51bGw7CgogICAgICBpZiAoZHJhZ1N0YXRlLnByZXZQYWdlKSB7CiAgICAgICAgZHJhZ1N0YXRlLnByZXZQYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOwogICAgICB9CgogICAgICBpZiAoZHJhZ1N0YXRlLm5leHRQYWdlKSB7CiAgICAgICAgZHJhZ1N0YXRlLm5leHRQYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOwogICAgICB9CiAgICB9LAoKICAgIGRvT25Ub3VjaE1vdmUoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMubm9EcmFnKSByZXR1cm47CgogICAgICB2YXIgZHJhZ1N0YXRlID0gdGhpcy5kcmFnU3RhdGU7CiAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07CgogICAgICBkcmFnU3RhdGUuc3BlZWRYID0gdG91Y2gucGFnZVggLSBkcmFnU3RhdGUuY3VycmVudExlZnQ7CiAgICAgIGRyYWdTdGF0ZS5jdXJyZW50TGVmdCA9IHRvdWNoLnBhZ2VYOwogICAgICBkcmFnU3RhdGUuY3VycmVudFRvcCA9IHRvdWNoLnBhZ2VZOwogICAgICBkcmFnU3RhdGUuY3VycmVudFRvcEFic29sdXRlID0gdG91Y2guY2xpZW50WTsKCiAgICAgIHZhciBvZmZzZXRMZWZ0ID0gZHJhZ1N0YXRlLmN1cnJlbnRMZWZ0IC0gZHJhZ1N0YXRlLnN0YXJ0TGVmdDsKICAgICAgdmFyIG9mZnNldFRvcCA9IGRyYWdTdGF0ZS5jdXJyZW50VG9wQWJzb2x1dGUgLSBkcmFnU3RhdGUuc3RhcnRUb3BBYnNvbHV0ZTsKCiAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhvZmZzZXRMZWZ0KTsKICAgICAgdmFyIGRpc3RhbmNlWSA9IE1hdGguYWJzKG9mZnNldFRvcCk7CiAgICAgIGlmIChkaXN0YW5jZVggPCA1IHx8IChkaXN0YW5jZVggPj0gNSAmJiBkaXN0YW5jZVkgPj0gMS43MyAqIGRpc3RhbmNlWCkpIHsKICAgICAgICB0aGlzLnVzZXJTY3JvbGxpbmcgPSB0cnVlOwogICAgICAgIHJldHVybjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnVzZXJTY3JvbGxpbmcgPSBmYWxzZTsKICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICB9CiAgICAgIG9mZnNldExlZnQgPSBNYXRoLm1pbihNYXRoLm1heCgtZHJhZ1N0YXRlLnBhZ2VXaWR0aCArIDEsIG9mZnNldExlZnQpLCBkcmFnU3RhdGUucGFnZVdpZHRoIC0gMSk7CgogICAgICB2YXIgdG93YXJkcyA9IG9mZnNldExlZnQgPCAwID8gJ25leHQnIDogJ3ByZXYnOwoKICAgICAgaWYgKGRyYWdTdGF0ZS5wcmV2UGFnZSAmJiB0b3dhcmRzID09PSAncHJldicpIHsKICAgICAgICB0aGlzLnRyYW5zbGF0ZShkcmFnU3RhdGUucHJldlBhZ2UsIG9mZnNldExlZnQgLSBkcmFnU3RhdGUucGFnZVdpZHRoKTsKICAgICAgfQogICAgICB0aGlzLnRyYW5zbGF0ZShkcmFnU3RhdGUuZHJhZ1BhZ2UsIG9mZnNldExlZnQpOwogICAgICBpZiAoZHJhZ1N0YXRlLm5leHRQYWdlICYmIHRvd2FyZHMgPT09ICduZXh0JykgewogICAgICAgIHRoaXMudHJhbnNsYXRlKGRyYWdTdGF0ZS5uZXh0UGFnZSwgb2Zmc2V0TGVmdCArIGRyYWdTdGF0ZS5wYWdlV2lkdGgpOwogICAgICB9CiAgICB9LAoKICAgIGRvT25Ub3VjaEVuZCgpIHsKICAgICAgaWYgKHRoaXMubm9EcmFnKSByZXR1cm47CgogICAgICB2YXIgZHJhZ1N0YXRlID0gdGhpcy5kcmFnU3RhdGU7CgogICAgICB2YXIgZHJhZ0R1cmF0aW9uID0gbmV3IERhdGUoKSAtIGRyYWdTdGF0ZS5zdGFydFRpbWU7CiAgICAgIHZhciB0b3dhcmRzID0gbnVsbDsKCiAgICAgIHZhciBvZmZzZXRMZWZ0ID0gZHJhZ1N0YXRlLmN1cnJlbnRMZWZ0IC0gZHJhZ1N0YXRlLnN0YXJ0TGVmdDsKICAgICAgdmFyIG9mZnNldFRvcCA9IGRyYWdTdGF0ZS5jdXJyZW50VG9wIC0gZHJhZ1N0YXRlLnN0YXJ0VG9wOwogICAgICB2YXIgcGFnZVdpZHRoID0gZHJhZ1N0YXRlLnBhZ2VXaWR0aDsKICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDsKICAgICAgdmFyIHBhZ2VDb3VudCA9IHRoaXMucGFnZXMubGVuZ3RoOwoKICAgICAgaWYgKGRyYWdEdXJhdGlvbiA8IDMwMCkgewogICAgICAgIGxldCBmaXJlVGFwID0gTWF0aC5hYnMob2Zmc2V0TGVmdCkgPCA1ICYmIE1hdGguYWJzKG9mZnNldFRvcCkgPCA1OwogICAgICAgIGlmIChpc05hTihvZmZzZXRMZWZ0KSB8fCBpc05hTihvZmZzZXRUb3ApKSB7CiAgICAgICAgICBmaXJlVGFwID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGZpcmVUYXApIHsKICAgICAgICAgIHRoaXMuJGNoaWxkcmVuW3RoaXMuaW5kZXhdLiRlbWl0KCd0YXAnKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmIChkcmFnRHVyYXRpb24gPCAzMDAgJiYgZHJhZ1N0YXRlLmN1cnJlbnRMZWZ0ID09PSB1bmRlZmluZWQpIHJldHVybjsKCiAgICAgIGlmIChkcmFnRHVyYXRpb24gPCAzMDAgfHwgTWF0aC5hYnMob2Zmc2V0TGVmdCkgPiBwYWdlV2lkdGggLyAyKSB7CiAgICAgICAgdG93YXJkcyA9IG9mZnNldExlZnQgPCAwID8gJ25leHQnIDogJ3ByZXYnOwogICAgICB9CgogICAgICBpZiAoIXRoaXMuY29udGludW91cykgewogICAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdG93YXJkcyA9PT0gJ3ByZXYnKSB8fCAoaW5kZXggPT09IHBhZ2VDb3VudCAtIDEgJiYgdG93YXJkcyA9PT0gJ25leHQnKSkgewogICAgICAgICAgdG93YXJkcyA9IG51bGw7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAodGhpcy4kY2hpbGRyZW4ubGVuZ3RoIDwgMikgewogICAgICAgIHRvd2FyZHMgPSBudWxsOwogICAgICB9CgogICAgICB0aGlzLmRvQW5pbWF0ZSh0b3dhcmRzLCB7CiAgICAgICAgb2Zmc2V0TGVmdDogb2Zmc2V0TGVmdCwKICAgICAgICBwYWdlV2lkdGg6IGRyYWdTdGF0ZS5wYWdlV2lkdGgsCiAgICAgICAgcHJldlBhZ2U6IGRyYWdTdGF0ZS5wcmV2UGFnZSwKICAgICAgICBjdXJyZW50UGFnZTogZHJhZ1N0YXRlLmRyYWdQYWdlLAogICAgICAgIG5leHRQYWdlOiBkcmFnU3RhdGUubmV4dFBhZ2UsCiAgICAgICAgc3BlZWRYOiBkcmFnU3RhdGUuc3BlZWRYCiAgICAgIH0pOwoKICAgICAgdGhpcy5kcmFnU3RhdGUgPSB7fTsKICAgIH0sCgogICAgaW5pdFRpbWVyKCkgewogICAgICBpZiAodGhpcy5hdXRvID4gMCAmJiAhdGhpcy50aW1lcikgewogICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7CiAgICAgICAgICBpZiAoIXRoaXMuY29udGludW91cyAmJiAodGhpcy5pbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDEpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFyVGltZXIoKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghdGhpcy5kcmFnZ2luZyAmJiAhdGhpcy5hbmltYXRpbmcpIHsKICAgICAgICAgICAgdGhpcy5uZXh0KCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgdGhpcy5hdXRvKTsKICAgICAgfQogICAgfSwKCiAgICBjbGVhclRpbWVyKCkgewogICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpOwogICAgICB0aGlzLnRpbWVyID0gbnVsbDsKICAgIH0KICB9LAoKICBkZXN0cm95ZWQoKSB7CiAgICBpZiAodGhpcy50aW1lcikgewogICAgICB0aGlzLmNsZWFyVGltZXIoKTsKICAgIH0KICAgIGlmICh0aGlzLnJlSW5pdFRpbWVyKSB7CiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlSW5pdFRpbWVyKTsKICAgICAgdGhpcy5yZUluaXRUaW1lciA9IG51bGw7CiAgICB9CiAgfSwKCiAgbW91bnRlZCgpIHsKICAgIHRoaXMucmVhZHkgPSB0cnVlOwoKICAgIHRoaXMuaW5pdFRpbWVyKCk7CgogICAgdGhpcy5yZUluaXRQYWdlcygpOwoKICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWw7CgogICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGV2ZW50KSA9PiB7CiAgICAgIGlmICh0aGlzLnByZXZlbnQpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7CiAgICAgIGlmICh0aGlzLnN0b3BQcm9wYWdhdGlvbikgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7CiAgICAgIGlmICh0aGlzLmFuaW1hdGluZykgcmV0dXJuOwogICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTsKICAgICAgdGhpcy51c2VyU2Nyb2xsaW5nID0gZmFsc2U7CiAgICAgIHRoaXMuZG9PblRvdWNoU3RhcnQoZXZlbnQpOwogICAgfSk7CgogICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZXZlbnQpID0+IHsKICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSByZXR1cm47CiAgICAgIGlmICh0aGlzLnRpbWVyKSB0aGlzLmNsZWFyVGltZXIoKTsKICAgICAgdGhpcy5kb09uVG91Y2hNb3ZlKGV2ZW50KTsKICAgIH0pOwoKICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoZXZlbnQpID0+IHsKICAgICAgaWYgKHRoaXMudXNlclNjcm9sbGluZykgewogICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLmRyYWdTdGF0ZSA9IHt9OwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHJldHVybjsKICAgICAgdGhpcy5pbml0VGltZXIoKTsKICAgICAgdGhpcy5kb09uVG91Y2hFbmQoZXZlbnQpOwogICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7CiAgICB9KTsKICB9Cn07Cg=="},{"version":3,"sources":["swipe.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"swipe.vue","sourceRoot":"node_modules/mint-ui/packages/swipe/src","sourcesContent":["<style>\n  @component-namespace mint {\n    @component swipe {\n      overflow: hidden;\n      position: relative;\n      height: 100%;\n\n      @descendent items-wrap {\n        position: relative;\n        overflow: hidden;\n        height: 100%;\n\n        > div {\n          position: absolute;\n          transform: translateX(-100%);\n          size: 100% 100%;\n          display: none;\n\n          @when active {\n            display: block;\n            transform: none;\n          }\n        }\n      }\n\n      @descendent indicators {\n        position: absolute;\n        bottom: 10px;\n        left: 50%;\n        transform: translateX(-50%);\n      }\n\n      @descendent indicator {\n        size: 8px 8px;\n        display: inline-block;\n        border-radius: 100%;\n        background: #000;\n        opacity: 0.2;\n        margin: 0 3px;\n\n        @when active {\n          background: #fff;\n        }\n      }\n    }\n  }\n</style>\n\n<template>\n  <div class=\"mint-swipe\">\n    <div class=\"mint-swipe-items-wrap\" ref=\"wrap\">\n      <slot></slot>\n    </div>\n    <div class=\"mint-swipe-indicators\" v-show=\"showIndicators\">\n      <div class=\"mint-swipe-indicator\"\n        v-for=\"(page, $index) in pages\"\n        :class=\"{ 'is-active': $index === index }\"></div>\n    </div>\n  </div>\n</template>\n\n<script>\n  import { once } from 'mint-ui/src/utils/dom';\n  import { addClass, removeClass } from 'mint-ui/src/utils/dom';\n\n  export default {\n    name: 'mt-swipe',\n\n    created() {\n      this.dragState = {};\n    },\n\n    data() {\n      return {\n        ready: false,\n        dragging: false,\n        userScrolling: false,\n        animating: false,\n        index: 0,\n        pages: [],\n        timer: null,\n        reInitTimer: null,\n        noDrag: false,\n        isDone: false\n      };\n    },\n\n    props: {\n      speed: {\n        type: Number,\n        default: 300\n      },\n\n      defaultIndex: {\n        type: Number,\n        default: 0\n      },\n\n      auto: {\n        type: Number,\n        default: 3000\n      },\n\n      continuous: {\n        type: Boolean,\n        default: true\n      },\n\n      showIndicators: {\n        type: Boolean,\n        default: true\n      },\n\n      noDragWhenSingle: {\n        type: Boolean,\n        default: true\n      },\n\n      prevent: {\n        type: Boolean,\n        default: false\n      },\n\n      stopPropagation: {\n        type: Boolean,\n        default: false\n      }\n    },\n\n    watch: {\n      index(newIndex) {\n        this.$emit('change', newIndex);\n      }\n    },\n\n    methods: {\n      swipeItemCreated() {\n        if (!this.ready) return;\n\n        clearTimeout(this.reInitTimer);\n        this.reInitTimer = setTimeout(() => {\n          this.reInitPages();\n        }, 100);\n      },\n\n      swipeItemDestroyed() {\n        if (!this.ready) return;\n\n        clearTimeout(this.reInitTimer);\n        this.reInitTimer = setTimeout(() => {\n          this.reInitPages();\n        }, 100);\n      },\n\n      rafTranslate(element, initOffset, offset, callback, nextElement) {\n        let ALPHA = 0.88;\n        this.animating = true;\n        var _offset = initOffset;\n        var raf = 0;\n\n        function animationLoop() {\n          if (Math.abs(_offset - offset) < 0.5) {\n            this.animating = false;\n            _offset = offset;\n            element.style.webkitTransform = '';\n            if (nextElement) {\n              nextElement.style.webkitTransform = '';\n            }\n            cancelAnimationFrame(raf);\n\n            if (callback) {\n              callback();\n            }\n\n            return;\n          }\n\n          _offset = ALPHA * _offset + (1.0 - ALPHA) * offset;\n          element.style.webkitTransform = `translate3d(${_offset}px, 0, 0)`;\n\n          if (nextElement) {\n            nextElement.style.webkitTransform = `translate3d(${_offset - offset}px, 0, 0)`;\n          }\n\n          raf = requestAnimationFrame(animationLoop.bind(this));\n        }\n\n        animationLoop.call(this);\n      },\n\n      translate(element, offset, speed, callback) {\n        if (speed) {\n          this.animating = true;\n          element.style.webkitTransition = '-webkit-transform ' + speed + 'ms ease-in-out';\n          setTimeout(() => {\n            element.style.webkitTransform = `translate3d(${offset}px, 0, 0)`;\n          }, 50);\n\n          var called = false;\n\n          var transitionEndCallback = () => {\n            if (called) return;\n            called = true;\n            this.animating = false;\n            element.style.webkitTransition = '';\n            element.style.webkitTransform = '';\n            if (callback) {\n              callback.apply(this, arguments);\n            }\n          };\n\n          once(element, 'webkitTransitionEnd', transitionEndCallback);\n          setTimeout(transitionEndCallback, speed + 100); // webkitTransitionEnd maybe not fire on lower version android.\n        } else {\n          element.style.webkitTransition = '';\n          element.style.webkitTransform = `translate3d(${offset}px, 0, 0)`;\n        }\n      },\n\n      reInitPages() {\n        var children = this.$children;\n        this.noDrag = children.length === 1 && this.noDragWhenSingle;\n\n        var pages = [];\n        var intDefaultIndex = Math.floor(this.defaultIndex);\n        var defaultIndex = (intDefaultIndex >= 0 && intDefaultIndex < children.length) ? intDefaultIndex : 0;\n        this.index = defaultIndex;\n\n        children.forEach(function(child, index) {\n          pages.push(child.$el);\n\n          removeClass(child.$el, 'is-active');\n\n          if (index === defaultIndex) {\n            addClass(child.$el, 'is-active');\n          }\n        });\n\n        this.pages = pages;\n      },\n\n      doAnimate(towards, options) {\n        if (this.$children.length === 0) return;\n        if (!options && this.$children.length < 2) return;\n\n        var prevPage, nextPage, currentPage, pageWidth, offsetLeft, speedX;\n        var speed = this.speed || 300;\n        var index = this.index;\n        var pages = this.pages;\n        var pageCount = pages.length;\n\n        if (!options) {\n          pageWidth = this.$el.clientWidth;\n          currentPage = pages[index];\n          prevPage = pages[index - 1];\n          nextPage = pages[index + 1];\n          if (this.continuous && pages.length > 1) {\n            if (!prevPage) {\n              prevPage = pages[pages.length - 1];\n            }\n            if (!nextPage) {\n              nextPage = pages[0];\n            }\n          }\n          if (prevPage) {\n            prevPage.style.display = 'block';\n            this.translate(prevPage, -pageWidth);\n          }\n          if (nextPage) {\n            nextPage.style.display = 'block';\n            this.translate(nextPage, pageWidth);\n          }\n        } else {\n          prevPage = options.prevPage;\n          currentPage = options.currentPage;\n          nextPage = options.nextPage;\n          pageWidth = options.pageWidth;\n          offsetLeft = options.offsetLeft;\n          speedX = options.speedX;\n        }\n\n        var newIndex;\n\n        var oldPage = this.$children[index].$el;\n\n        if (towards === 'prev') {\n          if (index > 0) {\n            newIndex = index - 1;\n          }\n          if (this.continuous && index === 0) {\n            newIndex = pageCount - 1;\n          }\n        } else if (towards === 'next') {\n          if (index < pageCount - 1) {\n            newIndex = index + 1;\n          }\n          if (this.continuous && index === pageCount - 1) {\n            newIndex = 0;\n          }\n        }\n\n        var callback = () => {\n          if (newIndex !== undefined) {\n            var newPage = this.$children[newIndex].$el;\n            removeClass(oldPage, 'is-active');\n            addClass(newPage, 'is-active');\n\n            this.index = newIndex;\n          }\n          if (this.isDone) {\n            this.end();\n          }\n\n          if (prevPage) {\n            prevPage.style.display = '';\n          }\n\n          if (nextPage) {\n            nextPage.style.display = '';\n          }\n        };\n\n        setTimeout(() => {\n          if (towards === 'next') {\n            this.isDone = true;\n            this.before(currentPage);\n            if (speedX) {\n              this.rafTranslate(currentPage, offsetLeft, -pageWidth, callback, nextPage);\n            } else {\n              this.translate(currentPage, -pageWidth, speed, callback);\n              if (nextPage) {\n                this.translate(nextPage, 0, speed);\n              }\n            }\n          } else if (towards === 'prev') {\n            this.isDone = true;\n            this.before(currentPage);\n            if (speedX) {\n              this.rafTranslate(currentPage, offsetLeft, pageWidth, callback, prevPage);\n            } else {\n              this.translate(currentPage, pageWidth, speed, callback);\n              if (prevPage) {\n                this.translate(prevPage, 0, speed);\n              }\n            }\n          } else {\n            this.isDone = false;\n            this.translate(currentPage, 0, speed, callback);\n            if (typeof offsetLeft !== 'undefined') {\n              if (prevPage && offsetLeft > 0) {\n                this.translate(prevPage, pageWidth * -1, speed);\n              }\n              if (nextPage && offsetLeft < 0) {\n                this.translate(nextPage, pageWidth, speed);\n              }\n            } else {\n              if (prevPage) {\n                this.translate(prevPage, pageWidth * -1, speed);\n              }\n              if (nextPage) {\n                this.translate(nextPage, pageWidth, speed);\n              }\n            }\n          }\n        }, 10);\n      },\n\n      next() {\n        this.doAnimate('next');\n      },\n\n      prev() {\n        this.doAnimate('prev');\n      },\n\n      before() {\n        this.$emit('before', this.index);\n      },\n\n      end() {\n        this.$emit('end', this.index);\n      },\n\n      doOnTouchStart(event) {\n        if (this.noDrag) return;\n\n        var element = this.$el;\n        var dragState = this.dragState;\n        var touch = event.touches[0];\n\n        dragState.startTime = new Date();\n        dragState.startLeft = touch.pageX;\n        dragState.startTop = touch.pageY;\n        dragState.startTopAbsolute = touch.clientY;\n\n        dragState.pageWidth = element.offsetWidth;\n        dragState.pageHeight = element.offsetHeight;\n\n        var prevPage = this.$children[this.index - 1];\n        var dragPage = this.$children[this.index];\n        var nextPage = this.$children[this.index + 1];\n\n        if (this.continuous && this.pages.length > 1) {\n          if (!prevPage) {\n            prevPage = this.$children[this.$children.length - 1];\n          }\n          if (!nextPage) {\n            nextPage = this.$children[0];\n          }\n        }\n\n        dragState.prevPage = prevPage ? prevPage.$el : null;\n        dragState.dragPage = dragPage ? dragPage.$el : null;\n        dragState.nextPage = nextPage ? nextPage.$el : null;\n\n        if (dragState.prevPage) {\n          dragState.prevPage.style.display = 'block';\n        }\n\n        if (dragState.nextPage) {\n          dragState.nextPage.style.display = 'block';\n        }\n      },\n\n      doOnTouchMove(event) {\n        if (this.noDrag) return;\n\n        var dragState = this.dragState;\n        var touch = event.touches[0];\n\n        dragState.speedX = touch.pageX - dragState.currentLeft;\n        dragState.currentLeft = touch.pageX;\n        dragState.currentTop = touch.pageY;\n        dragState.currentTopAbsolute = touch.clientY;\n\n        var offsetLeft = dragState.currentLeft - dragState.startLeft;\n        var offsetTop = dragState.currentTopAbsolute - dragState.startTopAbsolute;\n\n        var distanceX = Math.abs(offsetLeft);\n        var distanceY = Math.abs(offsetTop);\n        if (distanceX < 5 || (distanceX >= 5 && distanceY >= 1.73 * distanceX)) {\n          this.userScrolling = true;\n          return;\n        } else {\n          this.userScrolling = false;\n          event.preventDefault();\n        }\n        offsetLeft = Math.min(Math.max(-dragState.pageWidth + 1, offsetLeft), dragState.pageWidth - 1);\n\n        var towards = offsetLeft < 0 ? 'next' : 'prev';\n\n        if (dragState.prevPage && towards === 'prev') {\n          this.translate(dragState.prevPage, offsetLeft - dragState.pageWidth);\n        }\n        this.translate(dragState.dragPage, offsetLeft);\n        if (dragState.nextPage && towards === 'next') {\n          this.translate(dragState.nextPage, offsetLeft + dragState.pageWidth);\n        }\n      },\n\n      doOnTouchEnd() {\n        if (this.noDrag) return;\n\n        var dragState = this.dragState;\n\n        var dragDuration = new Date() - dragState.startTime;\n        var towards = null;\n\n        var offsetLeft = dragState.currentLeft - dragState.startLeft;\n        var offsetTop = dragState.currentTop - dragState.startTop;\n        var pageWidth = dragState.pageWidth;\n        var index = this.index;\n        var pageCount = this.pages.length;\n\n        if (dragDuration < 300) {\n          let fireTap = Math.abs(offsetLeft) < 5 && Math.abs(offsetTop) < 5;\n          if (isNaN(offsetLeft) || isNaN(offsetTop)) {\n            fireTap = true;\n          }\n          if (fireTap) {\n            this.$children[this.index].$emit('tap');\n          }\n        }\n\n        if (dragDuration < 300 && dragState.currentLeft === undefined) return;\n\n        if (dragDuration < 300 || Math.abs(offsetLeft) > pageWidth / 2) {\n          towards = offsetLeft < 0 ? 'next' : 'prev';\n        }\n\n        if (!this.continuous) {\n          if ((index === 0 && towards === 'prev') || (index === pageCount - 1 && towards === 'next')) {\n            towards = null;\n          }\n        }\n\n        if (this.$children.length < 2) {\n          towards = null;\n        }\n\n        this.doAnimate(towards, {\n          offsetLeft: offsetLeft,\n          pageWidth: dragState.pageWidth,\n          prevPage: dragState.prevPage,\n          currentPage: dragState.dragPage,\n          nextPage: dragState.nextPage,\n          speedX: dragState.speedX\n        });\n\n        this.dragState = {};\n      },\n\n      initTimer() {\n        if (this.auto > 0 && !this.timer) {\n          this.timer = setInterval(() => {\n            if (!this.continuous && (this.index >= this.pages.length - 1)) {\n              return this.clearTimer();\n            }\n            if (!this.dragging && !this.animating) {\n              this.next();\n            }\n          }, this.auto);\n        }\n      },\n\n      clearTimer() {\n        clearInterval(this.timer);\n        this.timer = null;\n      }\n    },\n\n    destroyed() {\n      if (this.timer) {\n        this.clearTimer();\n      }\n      if (this.reInitTimer) {\n        clearTimeout(this.reInitTimer);\n        this.reInitTimer = null;\n      }\n    },\n\n    mounted() {\n      this.ready = true;\n\n      this.initTimer();\n\n      this.reInitPages();\n\n      var element = this.$el;\n\n      element.addEventListener('touchstart', (event) => {\n        if (this.prevent) event.preventDefault();\n        if (this.stopPropagation) event.stopPropagation();\n        if (this.animating) return;\n        this.dragging = true;\n        this.userScrolling = false;\n        this.doOnTouchStart(event);\n      });\n\n      element.addEventListener('touchmove', (event) => {\n        if (!this.dragging) return;\n        if (this.timer) this.clearTimer();\n        this.doOnTouchMove(event);\n      });\n\n      element.addEventListener('touchend', (event) => {\n        if (this.userScrolling) {\n          this.dragging = false;\n          this.dragState = {};\n          return;\n        }\n        if (!this.dragging) return;\n        this.initTimer();\n        this.doOnTouchEnd(event);\n        this.dragging = false;\n      });\n    }\n  };\n</script>\n"]}]}