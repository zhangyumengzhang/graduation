{"remainingRequest":"D:\\2021graduate\\graduation\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\2021graduate\\graduation\\node_modules\\vue-aplayer\\src\\vue-aplayer.vue?vue&type=style&index=0&lang=scss&","dependencies":[{"path":"D:\\2021graduate\\graduation\\node_modules\\vue-aplayer\\src\\vue-aplayer.vue","mtime":1612070388741},{"path":"D:\\2021graduate\\graduation\\node_modules\\css-loader\\dist\\cjs.js","mtime":1594033219529},{"path":"D:\\2021graduate\\graduation\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1594033220124},{"path":"D:\\2021graduate\\graduation\\node_modules\\postcss-loader\\src\\index.js","mtime":1594033219961},{"path":"D:\\2021graduate\\graduation\\node_modules\\sass-loader\\dist\\cjs.js","mtime":1611475877198},{"path":"D:\\2021graduate\\graduation\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1594033213228},{"path":"D:\\2021graduate\\graduation\\node_modules\\vue-loader\\lib\\index.js","mtime":1594033220124}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCkBpbXBvcnQgIi4vc2Nzcy92YXJpYWJsZXMiOwoKLmFwbGF5ZXIgewogIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOwogIGNvbG9yOiAjMDAwOwogIGJhY2tncm91bmQtY29sb3I6ICNmZmY7CiAgbWFyZ2luOiA1cHg7CiAgYm94LXNoYWRvdzogMCAycHggMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjA3KSwgMCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjEpOwogIGJvcmRlci1yYWRpdXM6IDJweDsKICBvdmVyZmxvdzogaGlkZGVuOwogIHVzZXItc2VsZWN0OiBub25lOwogIGxpbmUtaGVpZ2h0OiBpbml0aWFsOwoKICAqIHsKICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94OwogIH0KCiAgLmFwbGF5ZXItbHJjLWNvbnRlbnQgewogICAgZGlzcGxheTogbm9uZTsKICB9CgogIC5hcGxheWVyLWJvZHkgewogICAgZGlzcGxheTogZmxleDsKCiAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAuYXBsYXllci1pbmZvIHsKICAgICAgZmxleC1ncm93OiAxOwogICAgICBkaXNwbGF5OiBmbGV4OwogICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwoKICAgICAgdGV4dC1hbGlnbjogc3RhcnQ7CiAgICAgIHBhZGRpbmc6IDE0cHggN3B4IDAgMTBweDsKICAgICAgaGVpZ2h0OiAkYXBsYXllci1oZWlnaHQ7CiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgIG92ZXJmbG93OiBoaWRkZW47CgogICAgICAuYXBsYXllci1tdXNpYyB7CiAgICAgICAgZmxleC1ncm93OiAxOwoKICAgICAgICBvdmVyZmxvdzogaGlkZGVuOwogICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7CiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDVweDsKICAgICAgICB1c2VyLXNlbGVjdDogdGV4dDsKICAgICAgICBjdXJzb3I6IGRlZmF1bHQ7CiAgICAgICAgcGFkZGluZy1ib3R0b206IDJweDsKCiAgICAgICAgLmFwbGF5ZXItdGl0bGUgewogICAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIH0KCiAgICAgICAgLmFwbGF5ZXItYXV0aG9yIHsKICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDsKICAgICAgICAgIGNvbG9yOiAjNjY2OwogICAgICAgIH0KICAgICAgfQoKICAgICAgLmFwbGF5ZXItbHJjIHsKICAgICAgICB6LWluZGV4OiAwOwogICAgICB9CiAgICB9CiAgfQoKICBhdWRpb1tjb250cm9sc10gewogICAgZGlzcGxheTogYmxvY2s7CiAgICB3aWR0aDogMTAwJTsKICB9CgogIC8vIE1pbmkgbW9kZQogICYuYXBsYXllci1uYXJyb3cgewogICAgd2lkdGg6ICRhcGxheWVyLWhlaWdodDsKICB9CgogICYuYXBsYXllci13aXRobHJjIHsKICAgIC5hcGxheWVyLWJvZHkgewogICAgICAuYXBsYXllci1waWMgewogICAgICAgIGhlaWdodDogJGFwbGF5ZXItaGVpZ2h0LWxyYzsKICAgICAgICB3aWR0aDogJGFwbGF5ZXItaGVpZ2h0LWxyYzsKICAgICAgfQoKICAgICAgLmFwbGF5ZXItaW5mbyB7CiAgICAgICAgaGVpZ2h0OiAkYXBsYXllci1oZWlnaHQtbHJjOwogICAgICB9CgogICAgICAuYXBsYXllci1pbmZvIHsKICAgICAgICBwYWRkaW5nOiAxMHB4IDdweCAwIDdweDsKICAgICAgfQogICAgfQogIH0KCiAgJi5hcGxheWVyLXdpdGhsaXN0IHsKICAgIC5hcGxheWVyLWJvZHkgewogICAgICAuYXBsYXllci1pbmZvIHsKICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U5ZTllOTsKICAgICAgfQoKICAgICAgLmFwbGF5ZXItY29udHJvbGxlciAuYXBsYXllci10aW1lIC5hcGxheWVyLWljb24uYXBsYXllci1pY29uLW1lbnUgewogICAgICAgIGRpc3BsYXk6IGJsb2NrOwogICAgICB9CiAgICB9CiAgfQoKICAvKiBmbG9hdGluZyBwbGF5ZXIgb24gdG9wICovCiAgcG9zaXRpb246IHJlbGF0aXZlOwogICYuYXBsYXllci1mbG9hdCB7CiAgICB6LWluZGV4OiAxOwogIH0KfQoKQGtleWZyYW1lcyBhcGxheWVyLXJvbGwgewogIDAlIHsKICAgIGxlZnQ6IDAKICB9CiAgMTAwJSB7CiAgICBsZWZ0OiAtMTAwJQogIH0KfQo="},{"version":3,"sources":["vue-aplayer.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA62BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vue-aplayer.vue","sourceRoot":"node_modules/vue-aplayer/src","sourcesContent":["<template>\n  <div\n    class=\"aplayer\"\n    :class=\"{\n      'aplayer-narrow': isMiniMode,\n      'aplayer-withlist' : !isMiniMode && musicList.length > 0,\n      'aplayer-withlrc': !isMiniMode && (!!$slots.display || shouldShowLrc),\n      'aplayer-float': isFloatMode,\n      'aplayer-loading': isPlaying && isLoading\n    }\"\n    :style=\"floatStyleObj\"\n  >\n    <div class=\"aplayer-body\">\n      <thumbnail\n        :pic=\"currentMusic.pic\"\n        :playing=\"isPlaying\"\n        :enable-drag=\"isFloatMode\"\n        :theme=\"currentTheme\"\n        @toggleplay=\"toggle\"\n        @dragbegin=\"onDragBegin\"\n        @dragging=\"onDragAround\"\n      />\n      <div class=\"aplayer-info\" v-show=\"!isMiniMode\">\n        <div class=\"aplayer-music\">\n          <span class=\"aplayer-title\">{{ currentMusic.title || 'Untitled' }}</span>\n          <span class=\"aplayer-author\">{{ currentMusic.artist || currentMusic.author || 'Unknown' }}</span>\n        </div>\n        <slot name=\"display\" :current-music=\"currentMusic\" :play-stat=\"playStat\">\n          <lyrics :current-music=\"currentMusic\" :play-stat=\"playStat\" v-if=\"shouldShowLrc\" />\n        </slot>\n        <controls\n          :shuffle=\"shouldShuffle\"\n          :repeat=\"repeatMode\"\n          :stat=\"playStat\"\n          :volume=\"audioVolume\"\n          :muted=\"isAudioMuted\"\n          :theme=\"currentTheme\"\n          @toggleshuffle=\"shouldShuffle = !shouldShuffle\"\n          @togglelist=\"showList = !showList\"\n          @togglemute=\"toggleMute\"\n          @setvolume=\"setAudioVolume\"\n          @dragbegin=\"onProgressDragBegin\"\n          @dragend=\"onProgressDragEnd\"\n          @dragging=\"onProgressDragging\"\n          @nextmode=\"setNextMode\"\n        />\n      </div>\n    </div>\n    <audio ref=\"audio\"></audio>\n    <music-list\n      :show=\"showList && !isMiniMode\"\n      :current-music=\"currentMusic\"\n      :music-list=\"musicList\"\n      :play-index=\"playIndex\"\n      :listmaxheight=\"listmaxheight || listMaxHeight\"\n      :theme=\"currentTheme\"\n      @selectsong=\"onSelectSong\"\n    />\n  </div>\n</template>\n<script type=\"text/babel\">\n  import Vue from 'vue'\n  import Thumbnail from './components/aplayer-thumbnail.vue'\n  import MusicList from './components/aplayer-list.vue'\n  import Controls from './components/aplayer-controller.vue'\n  import Lyrics from './components/aplayer-lrc.vue'\n  import { deprecatedProp, versionCompare, warn } from './utils'\n\n  let versionBadgePrinted = false\n  const canUseSync = versionCompare(Vue.version, '2.3.0') >= 0\n\n  /**\n   * memorize self-adapting theme for cover image urls\n   * @type {Object.<url, rgb()>}\n   */\n  const picThemeCache = {}\n\n  // mutex playing instance\n  let activeMutex = null\n\n\n  const REPEAT = {\n    NONE: 'none',\n    MUSIC: 'music',\n    LIST: 'list',\n    NO_REPEAT: 'no-repeat',\n    REPEAT_ONE: 'repeat-one',\n    REPEAT_ALL: 'repeat-all',\n  };\n\n  const VueAPlayer = {\n    name: 'APlayer',\n    disableVersionBadge: false,\n    components: {\n      Thumbnail,\n      Controls,\n      MusicList,\n      Lyrics,\n    },\n    props: {\n      music: {\n        type: Object,\n        required: true,\n        validator (song) {\n          if (song.url) {\n            deprecatedProp('music.url', '1.4.0', 'music.src')\n          }\n          if (song.author) {\n            deprecatedProp('music.author', '1.4.1', 'music.artist')\n          }\n          return song.src || song.url\n        },\n      },\n      list: {\n        type: Array,\n        default () {\n          return []\n        },\n      },\n      mini: {\n        type: Boolean,\n        default: false,\n      },\n      showLrc: {\n        type: Boolean,\n        default: false,\n      },\n      mutex: {\n        type: Boolean,\n        default: true,\n      },\n      theme: {\n        type: String,\n        default: '#41b883',\n      },\n\n      listMaxHeight: String,\n      /**\n       * @since 1.4.1\n       * Fold playlist initially\n       */\n      listFolded: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * @since 1.2.0 Float mode\n       */\n      float: {\n        type: Boolean,\n        default: false,\n      },\n\n      // Audio attributes as props\n      // since 1.4.0\n      // autoplay controls muted preload volume\n      // autoplay is not observable\n\n      /**\n       * @since 1.4.0\n       * not observable\n       */\n      autoplay: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * @since 1.4.0\n       * whether to show native audio controls below Vue-APlayer\n       * only work in development environment and not mini mode\n       *\n       * observable\n       */\n      controls: {\n        type: Boolean,\n        default: false,\n      },\n\n      /**\n       * @since 1.4.0\n       * observable, sync\n       */\n      muted: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * @since 1.4.0\n       * observable\n       */\n      preload: String,\n\n      /**\n       * @since 1.4.0\n       * observable, sync\n       */\n      volume: {\n        type: Number,\n        default: 0.8,\n        validator (value) {\n          return value >= 0 && value <= 1\n        },\n      },\n\n      // play order control\n      // since 1.5.0\n\n      /**\n       * @since 1.5.0\n       * @see https://support.apple.com/en-us/HT207230\n       * twoWay\n       */\n      shuffle: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * @since 1.5.0\n       * @see https://support.apple.com/en-us/HT207230\n       * twoWay\n       */\n      repeat: {\n        type: String,\n        default: REPEAT.NO_REPEAT,\n      },\n\n\n      // deprecated props\n\n      /**\n       * @deprecated since 1.1.2, use listMaxHeight instead\n       */\n      listmaxheight: {\n        type: String,\n        validator (value) {\n          if (value) {\n            deprecatedProp('listmaxheight', '1.1.2', 'listMaxHeight')\n          }\n          return true\n        },\n      },\n      /**\n       * @deprecated since 1.1.2, use mini instead\n       */\n      narrow: {\n        type: Boolean,\n        default: false,\n        validator (value) {\n          if (value) {\n            deprecatedProp('narrow', '1.1.2', 'mini')\n          }\n          return true\n        },\n      },\n      /**\n       * @deprecated since 1.2.2\n       */\n      showlrc: {\n        type: Boolean,\n        default: false,\n        validator (value) {\n          if (value) {\n            deprecatedProp('showlrc', '1.2.2', 'showLrc')\n          }\n          return true\n        },\n      },\n      /**\n       * @deprecated and REMOVED since 1.5.0\n       */\n      // mode: {\n      //   type: String,\n      //   default: 'circulation',\n      //   validator (value) {\n      //     if (value) {\n      //       deprecatedProp('mode', '1.5.0', 'shuffle and repeat')\n      //     }\n      //     return true\n      //   }\n      // },\n    },\n    data () {\n      return {\n        internalMusic: this.music,\n        isPlaying: false,\n        isSeeking: false,\n        wasPlayingBeforeSeeking: false,\n        isMobile: /mobile/i.test(window.navigator.userAgent),\n        playStat: {\n          duration: 0,\n          loadedTime: 0,\n          playedTime: 0,\n        },\n        showList: !this.listFolded,\n\n        // handle Promise returned from audio.play()\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play\n        audioPlayPromise: Promise.resolve(),\n\n\n        // @since 1.2.0 float mode\n\n        floatOriginX: 0,\n        floatOriginY: 0,\n        floatOffsetLeft: 0,\n        floatOffsetTop: 0,\n\n\n        // @since 1.3.0 self adapting theme\n        selfAdaptingTheme: null,\n\n\n        // @since 1.4.0\n        // sync muted, volume\n\n        internalMuted: this.muted,\n        internalVolume: this.volume,\n\n        // @since 1.4.1\n        // Loading indicator\n        isLoading: false,\n\n\n        // @since 1.5.1\n        // sync shuffle, repeat\n        internalShuffle: this.shuffle,\n        internalRepeat: this.repeat,\n        // for shuffling\n        shuffledList: [],\n      }\n    },\n    computed: {\n      // alias for $refs.audio\n      audio () {\n        return this.$refs.audio\n      },\n\n      // sync music\n      currentMusic: {\n        get () {\n          return this.internalMusic\n        },\n        set (val) {\n          canUseSync && this.$emit('update:music', val)\n          this.internalMusic = val\n        },\n      },\n      // compatible for deprecated props\n      isMiniMode () {\n        return this.mini || this.narrow\n      },\n      shouldShowLrc () {\n        return this.showLrc || this.showlrc\n      },\n\n      // props wrappers\n\n      currentTheme () {\n        return this.selfAdaptingTheme || this.currentMusic.theme || this.theme\n      },\n      isFloatMode () {\n        return this.float && !this.isMobile\n      },\n      shouldAutoplay () {\n        if (this.isMobile) return false\n        return this.autoplay\n      },\n      musicList () {\n        return this.list\n      },\n      shouldShowNativeControls () {\n        return process.env.NODE_ENV !== 'production' &&\n          this.controls &&\n          !this.isMiniMode\n      },\n\n      // useful\n\n      floatStyleObj () {\n        // transform: translate(floatOffsetLeft, floatOffsetY)\n        return {\n          transform: `translate(${this.floatOffsetLeft}px, ${this.floatOffsetTop}px)`,\n          webkitTransform: `translate(${this.floatOffsetLeft}px, ${this.floatOffsetTop}px)`,\n        }\n      },\n      currentPicStyleObj () {\n        if (this.currentMusic && this.currentMusic.pic) {\n          return {\n            backgroundImage: `url(${this.currentMusic.pic})`,\n          }\n        }\n        return {}\n      },\n      loadProgress () {\n        if (this.playStat.duration === 0) return 0\n        return this.playStat.loadedTime / this.playStat.duration\n      },\n      playProgress () {\n        if (this.playStat.duration === 0) return 0\n        return this.playStat.playedTime / this.playStat.duration\n      },\n      playIndex: {\n        get () {\n          return this.shuffledList.indexOf(this.currentMusic)\n        },\n        set (val) {\n          this.currentMusic = this.shuffledList[val % this.shuffledList.length]\n        },\n      },\n      shouldRepeat () {\n        return this.repeatMode !== REPEAT.NO_REPEAT\n      },\n\n      // since 1.4.0\n      // sync muted, volume\n\n      isAudioMuted: {\n        get () {\n          return this.internalMuted\n        },\n        set (val) {\n          canUseSync && this.$emit('update:muted', val)\n          this.internalMuted = val\n        },\n      },\n      audioVolume: {\n        get () {\n          return this.internalVolume\n        },\n        set (val) {\n          canUseSync && this.$emit('update:volume', val)\n          this.internalVolume = val\n        },\n      },\n\n\n      // since 1.5.0\n      // sync shuffle, repeat\n      shouldShuffle: {\n        get () {\n          return this.internalShuffle\n        },\n        set (val) {\n          canUseSync && this.$emit('update:shuffle', val)\n          this.internalShuffle = val\n        },\n      },\n      repeatMode: {\n        get () {\n          switch (this.internalRepeat) {\n            case REPEAT.NONE:\n            case REPEAT.NO_REPEAT:\n              return REPEAT.NO_REPEAT\n            case REPEAT.MUSIC:\n            case REPEAT.REPEAT_ONE:\n              return REPEAT.REPEAT_ONE\n            default:\n              return REPEAT.REPEAT_ALL\n          }\n        },\n        set (val) {\n          canUseSync && this.$emit('update:repeat', val)\n          this.internalRepeat = val\n        },\n      },\n    },\n    methods: {\n      // Float mode\n\n      onDragBegin () {\n        this.floatOriginX = this.floatOffsetLeft\n        this.floatOriginY = this.floatOffsetTop\n      },\n      onDragAround ({ offsetLeft, offsetTop }) {\n        this.floatOffsetLeft = this.floatOriginX + offsetLeft\n        this.floatOffsetTop = this.floatOriginY + offsetTop\n      },\n\n      // functions\n\n      setNextMode () {\n        if (this.repeatMode === REPEAT.REPEAT_ALL) {\n          this.repeatMode = REPEAT.REPEAT_ONE\n        } else if (this.repeatMode === REPEAT.REPEAT_ONE) {\n          this.repeatMode = REPEAT.NO_REPEAT\n        } else {\n          this.repeatMode = REPEAT.REPEAT_ALL\n        }\n      },\n      thenPlay () {\n        this.$nextTick(() => {\n          this.play()\n        })\n      },\n\n      // controls\n\n      // play/pause\n\n      toggle () {\n        if (!this.audio.paused) {\n          this.pause()\n        } else {\n          this.play()\n        }\n      },\n      play () {\n        if (this.mutex) {\n          if (activeMutex && activeMutex !== this) {\n            activeMutex.pause()\n          }\n          activeMutex = this\n        }\n        // handle .play() Promise\n        const audioPlayPromise = this.audio.play()\n        if (audioPlayPromise) {\n          return this.audioPlayPromise = new Promise((resolve, reject) => {\n            // rejectPlayPromise is to force reject audioPlayPromise if it's still pending when pause() is called\n            this.rejectPlayPromise = reject\n            audioPlayPromise.then((res) => {\n              this.rejectPlayPromise = null\n              resolve(res)\n            }).catch(warn)\n          })\n        }\n      },\n      pause () {\n        this.audioPlayPromise\n          .then(() => {\n            this.audio.pause()\n          })\n          // Avoid force rejection throws Uncaught\n          .catch(() => {\n            this.audio.pause()\n          })\n\n        // audioPlayPromise is still pending\n        if (this.rejectPlayPromise) {\n          // force reject playPromise\n          this.rejectPlayPromise()\n          this.rejectPlayPromise = null\n        }\n      },\n\n      // progress bar\n\n      onProgressDragBegin (val) {\n        this.wasPlayingBeforeSeeking = this.isPlaying\n        this.pause()\n        this.isSeeking = true\n\n        // handle load failures\n        if (!isNaN(this.audio.duration)) {\n          this.audio.currentTime = this.audio.duration * val\n        }\n      },\n      onProgressDragging (val) {\n        if (isNaN(this.audio.duration)) {\n          this.playStat.playedTime = 0\n        } else {\n          this.audio.currentTime = this.audio.duration * val\n        }\n      },\n      onProgressDragEnd (val) {\n        this.isSeeking = false\n\n        if (this.wasPlayingBeforeSeeking) {\n          this.thenPlay()\n        }\n      },\n\n      // volume\n\n      toggleMute () {\n        this.setAudioMuted(!this.audio.muted)\n      },\n      setAudioMuted (val) {\n        this.audio.muted = val\n      },\n      setAudioVolume (val) {\n        this.audio.volume = val\n        if (val > 0) {\n          this.setAudioMuted(false)\n        }\n      },\n\n      // playlist\n\n      getShuffledList () {\n        if (!this.list.length) {\n          return [this.internalMusic]\n        }\n        let unshuffled = [...this.list]\n        if (!this.internalShuffle || unshuffled.length <= 1) {\n          return unshuffled\n        }\n\n        let indexOfCurrentMusic = unshuffled.indexOf(this.internalMusic)\n        if (unshuffled.length === 2 && indexOfCurrentMusic !== -1) {\n          if (indexOfCurrentMusic === 0) {\n            return unshuffled\n          } else {\n            return [this.internalMusic, unshuffled[0]]\n          }\n        }\n        // shuffle list\n        // @see https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array\n        for (let i = unshuffled.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1))\n          const tmp = unshuffled[i]\n          unshuffled[i] = unshuffled[j]\n          unshuffled[j] = tmp\n        }\n\n        // take currentMusic to first\n        if (indexOfCurrentMusic !== -1) {\n          indexOfCurrentMusic = unshuffled.indexOf(this.internalMusic)\n          if (indexOfCurrentMusic !== 0) {\n            [unshuffled[0], unshuffled[indexOfCurrentMusic]] = [unshuffled[indexOfCurrentMusic], unshuffled[0]]\n          }\n        }\n\n        return unshuffled\n      },\n\n      onSelectSong (song) {\n        if (this.currentMusic === song) {\n          this.toggle()\n        } else {\n          this.currentMusic = song\n          this.thenPlay()\n        }\n      },\n\n      // event handlers\n      // for keeping up with audio states\n\n      onAudioPlay () {\n        this.isPlaying = true\n      },\n      onAudioPause () {\n        this.isPlaying = false\n      },\n      onAudioWaiting () {\n        this.isLoading = true\n      },\n      onAudioCanplay () {\n        this.isLoading = false\n      },\n      onAudioDurationChange () {\n        if (this.audio.duration !== 1) {\n          this.playStat.duration = this.audio.duration\n        }\n      },\n      onAudioProgress () {\n        if (this.audio.buffered.length) {\n          this.playStat.loadedTime = this.audio.buffered.end(this.audio.buffered.length - 1)\n        } else {\n          this.playStat.loadedTime = 0\n        }\n      },\n      onAudioTimeUpdate () {\n        this.playStat.playedTime = this.audio.currentTime\n      },\n      onAudioSeeking () {\n        this.playStat.playedTime = this.audio.currentTime\n      },\n      onAudioSeeked () {\n        this.playStat.playedTime = this.audio.currentTime\n      },\n      onAudioVolumeChange () {\n        this.audioVolume = this.audio.volume\n        this.isAudioMuted = this.audio.muted\n      },\n      onAudioEnded () {\n        // determine next song according to shuffle and repeat\n        if (this.repeatMode === REPEAT.REPEAT_ALL) {\n          if (this.shouldShuffle && this.playIndex === this.shuffledList.length - 1) {\n            this.shuffledList = this.getShuffledList()\n          }\n          this.playIndex++\n          this.thenPlay()\n        } else if (this.repeatMode === REPEAT.REPEAT_ONE) {\n          this.thenPlay()\n        } else {\n          this.playIndex++\n          if (this.playIndex !== 0) {\n            this.thenPlay()\n          } else if (this.shuffledList.length === 1) {\n            this.audio.currentTime = 0\n          }\n        }\n      },\n\n      initAudio () {\n\n        // since 1.4.0 Audio attributes as props\n\n        this.audio.controls = this.shouldShowNativeControls\n        this.audio.muted = this.muted\n        this.audio.preload = this.preload\n        this.audio.volume = this.volume\n\n\n        // since 1.4.0 Emit as many native audio events\n        // @see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events\n\n        const mediaEvents = [\n          'abort',\n          'canplay', 'canplaythrough',\n          'durationchange',\n          'emptied', 'encrypted', 'ended', 'error',\n          'interruptbegin', 'interruptend',\n          'loadeddata', 'loadedmetadata', 'loadstart',\n          'mozaudioavailable',\n          'pause', 'play', 'playing', 'progress',\n          'ratechange',\n          'seeked', 'seeking', 'stalled', 'suspend',\n          'timeupdate',\n          'volumechange',\n          'waiting',\n        ]\n        mediaEvents.forEach(event => {\n          this.audio.addEventListener(event, e => this.$emit(event, e))\n        })\n\n\n        // event handlers\n        // they don't emit native media events\n\n        this.audio.addEventListener('play', this.onAudioPlay)\n        this.audio.addEventListener('pause', this.onAudioPause)\n        this.audio.addEventListener('abort', this.onAudioPause)\n        this.audio.addEventListener('waiting', this.onAudioWaiting)\n        this.audio.addEventListener('canplay', this.onAudioCanplay)\n        this.audio.addEventListener('progress', this.onAudioProgress)\n        this.audio.addEventListener('durationchange', this.onAudioDurationChange)\n        this.audio.addEventListener('seeking', this.onAudioSeeking)\n        this.audio.addEventListener('seeked', this.onAudioSeeked)\n        this.audio.addEventListener('timeupdate', this.onAudioTimeUpdate)\n        this.audio.addEventListener('volumechange', this.onAudioVolumeChange)\n        this.audio.addEventListener('ended', this.onAudioEnded)\n\n\n        if (this.currentMusic) {\n          this.audio.src = this.currentMusic.src || this.currentMusic.url\n        }\n      },\n\n      setSelfAdaptingTheme () {\n        // auto theme according to current music cover image\n        if ((this.currentMusic.theme || this.theme) === 'pic') {\n          const pic = this.currentMusic.pic\n          // use cache\n          if (picThemeCache[pic]) {\n            this.selfAdaptingTheme = picThemeCache[pic]\n          } else {\n            try {\n              new ColorThief().getColorAsync(pic, ([r, g, b]) => {\n                picThemeCache[pic] = `rgb(${r}, ${g}, ${b})`\n                this.selfAdaptingTheme = `rgb(${r}, ${g}, ${b})`\n              })\n            } catch (e) {\n              warn('color-thief is required to support self-adapting theme')\n            }\n          }\n        } else {\n          this.selfAdaptingTheme = null\n        }\n      },\n    },\n    watch: {\n      music (music) {\n        this.internalMusic = music\n      },\n\n      currentMusic: {\n        handler (music) {\n          // async\n          this.setSelfAdaptingTheme()\n\n          const src = music.src || music.url\n          // HLS support\n          if (/\\.m3u8(?=(#|\\?|$))/.test(src)) {\n            if (this.audio.canPlayType('application/x-mpegURL') || this.audio.canPlayType('application/vnd.apple.mpegURL')) {\n              this.audio.src = src\n            } else {\n              try {\n                const Hls = require('hls.js')\n                if (Hls.isSupported()) {\n                  if (!this.hls) {\n                    this.hls = new Hls()\n                  }\n                  this.hls.loadSource(src)\n                  this.hls.attachMedia(this.audio)\n                } else {\n                  warn('HLS is not supported on your browser')\n                  this.audio.src = src\n                }\n              } catch (e) {\n                warn('hls.js is required to support m3u8')\n                this.audio.src = src\n              }\n            }\n          } else {\n            this.audio.src = src\n          }\n          // self-adapting theme color\n        },\n      },\n\n      // since 1.4.0\n      // observe controls, muted, preload, volume\n\n      shouldShowNativeControls (val) {\n        this.audio.controls = val\n      },\n      isAudioMuted (val) {\n        this.audio.muted = val\n      },\n      preload (val) {\n        this.audio.preload = val\n      },\n      audioVolume (val) {\n        this.audio.volume = val\n      },\n\n      // sync muted, volume\n\n      muted (val) {\n        this.internalMuted = val\n      },\n      volume (val) {\n        this.internalVolume = val\n      },\n\n\n      // sync shuffle, repeat\n      shuffle (val) {\n        this.internalShuffle = val\n      },\n      repeat (val) {\n        this.internalRepeat = val\n      },\n    },\n    beforeCreate () {\n      if (!VueAPlayer.disableVersionBadge && !versionBadgePrinted) {\n        // version badge\n        console.log(`\\n\\n %c Vue-APlayer ${VERSION} %c vue-aplayer.js.org \\n`, 'color: #fff; background:#41b883; padding:5px 0;', 'color: #fff; background: #35495e; padding:5px 0;')\n        versionBadgePrinted = true\n      }\n    },\n    created () {\n      this.shuffledList = this.getShuffledList()\n    },\n    mounted () {\n      this.initAudio()\n      this.setSelfAdaptingTheme()\n      if (this.autoplay) this.play()\n    },\n    beforeDestroy () {\n      if (activeMutex === this) {\n        activeMutex = null\n      }\n      if (this.hls) {\n        this.hls.destroy()\n      }\n    },\n  }\n\n  export default VueAPlayer\n\n</script>\n\n<style lang=\"scss\">\n  @import \"./scss/variables\";\n\n  .aplayer {\n    font-family: Arial, Helvetica, sans-serif;\n    color: #000;\n    background-color: #fff;\n    margin: 5px;\n    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.07), 0 1px 5px 0 rgba(0, 0, 0, 0.1);\n    border-radius: 2px;\n    overflow: hidden;\n    user-select: none;\n    line-height: initial;\n\n    * {\n      box-sizing: content-box;\n    }\n\n    .aplayer-lrc-content {\n      display: none;\n    }\n\n    .aplayer-body {\n      display: flex;\n\n      position: relative;\n      .aplayer-info {\n        flex-grow: 1;\n        display: flex;\n        flex-direction: column;\n\n        text-align: start;\n        padding: 14px 7px 0 10px;\n        height: $aplayer-height;\n        box-sizing: border-box;\n        overflow: hidden;\n\n        .aplayer-music {\n          flex-grow: 1;\n\n          overflow: hidden;\n          white-space: nowrap;\n          text-overflow: ellipsis;\n          margin-left: 5px;\n          user-select: text;\n          cursor: default;\n          padding-bottom: 2px;\n\n          .aplayer-title {\n            font-size: 14px;\n          }\n\n          .aplayer-author {\n            font-size: 12px;\n            color: #666;\n          }\n        }\n\n        .aplayer-lrc {\n          z-index: 0;\n        }\n      }\n    }\n\n    audio[controls] {\n      display: block;\n      width: 100%;\n    }\n\n    // Mini mode\n    &.aplayer-narrow {\n      width: $aplayer-height;\n    }\n\n    &.aplayer-withlrc {\n      .aplayer-body {\n        .aplayer-pic {\n          height: $aplayer-height-lrc;\n          width: $aplayer-height-lrc;\n        }\n\n        .aplayer-info {\n          height: $aplayer-height-lrc;\n        }\n\n        .aplayer-info {\n          padding: 10px 7px 0 7px;\n        }\n      }\n    }\n\n    &.aplayer-withlist {\n      .aplayer-body {\n        .aplayer-info {\n          border-bottom: 1px solid #e9e9e9;\n        }\n\n        .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu {\n          display: block;\n        }\n      }\n    }\n\n    /* floating player on top */\n    position: relative;\n    &.aplayer-float {\n      z-index: 1;\n    }\n  }\n\n  @keyframes aplayer-roll {\n    0% {\n      left: 0\n    }\n    100% {\n      left: -100%\n    }\n  }\n</style>"]}]}